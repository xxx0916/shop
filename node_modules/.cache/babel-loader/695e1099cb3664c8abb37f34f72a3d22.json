{"ast":null,"code":"// 引入Swiper\n// import Swiper from 'swiper'\nexport default {\n  props: [\"list\"],\n\n  mounted() {// 第一次写首页大轮播图的时候:在mounted当中书写是不可以的，但是为什么现在这里可以了？\n    // 第一次书写轮播图的时候，是在当前组件内部发请求、动态渲染结构的【前台至少服务器数据需要回来】，因此第一种的写法在这里不行\n    // 现在这种写法为什么可以：因为请求是父组件发的，父组件通过pros传递过来的，而且结构已经有了的情况下执行mouned\n\n    /* var mySwiper = new Swiper(this.$refs.cur, {\r\n        loop: true, // 循环模式选项\r\n        // 如果需要分页器\r\n        pagination: {\r\n            el: '.swiper-pagination',\r\n            //点击小球切换图片\r\n            clickable: true,\r\n        },\r\n          // 如果需要前进后退按钮\r\n        navigation: {\r\n            nextEl: '.swiper-button-next',\r\n            prevEl: '.swiper-button-prev',\r\n        },\r\n    }) */\n  },\n\n  watch: {// list: {\n    //     //立即监听：不管数据发没发生变化，我上来立即监听一次\n    //     // 为什么watch监听不到list:因为这个数据从来没有发生变化（数据是父亲给的，父亲给的时候就是一个对象，对象里面该有的数据都是有的）\n    //     immediate: true,\n    //     handler() {\n    //         // 只能监听到数据已经有了，但是v-for动态渲染结构我们还是没有办法确认的，因此还是需要用nextTick\n    //         this.$nextTick(() => {\n    //             var mySwiper = new Swiper(this.$refs.cur, {\n    //                 loop: true,\n    //                 // 如果需要分页器\n    //                 pagination: {\n    //                     el: \".swiper-pagination\",\n    //                     //点击小球切换图片\n    //                     clickable: true,\n    //                 },\n    //                 // 如果需要前进后退按钮\n    //                 navigation: {\n    //                     nextEl: \".swiper-button-next\",\n    //                     prevEl: \".swiper-button-prev\",\n    //                 },\n    //             });\n    //         });\n    //     }\n    // }\n  }\n};","map":null,"metadata":{},"sourceType":"module"}